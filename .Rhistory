## Wczytanie danych
pop <- read.csv('pop.csv')
setwd('C:/Users/marty/Desktop/GITHUB/ts')
## Wczytanie danych
pop <- read.csv('pop.csv')
veg <- read.csv('veg.csv')
View(pop)
colnames(pop) <- c('data','liczba')
View(veg)
colnames(veg) <- c('data', 'cena')
str(pop)
str(veg)
plot(pop)
str(pop)
pop$data <- as.Date(pop$data)
str(pop)
veg$data <- ad.Date(veg$data)
veg$data <- as.Date(veg$data)
plot(pop)
format(pop, scientific=FALSE)
plot(pop)
plot(format(pop, scientific=FALSE))
plot(pop)
plot(veg)
is.ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
ts(pop)
as.ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
as.ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
View(pop)
colnames(pop) <- c('data','liczba')
colnames(veg) <- c('data', 'cena')
pop$data <- as.Date(pop$data)
veg$data <- as.Date(veg$data)
ts(pop)
pop <- ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
pop<-as.ts(pop)
library(zoo)
pop <- read.zoo(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
veg <- read.csv('veg.csv')
colnames(pop) <- c('data','liczba')
pop <- read.zoo(pop)
pop
is.ts(pop)
pop <- as.ts(pop)
pop
## Wczytanie danych
pop <- read.csv('pop.csv')
pop <- as.ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
pop$data <- as.Date(pop$data)
pop <- as.ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
colnames(pop) <- c('data','liczba')
pop$data <- as.Date(pop$data)
pop <- as.ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
colnames(pop) <- c('data','liczba')
pop <- ts(pop)
## Wczytanie danych
pop <- read.csv('pop.csv')
pop <- ts(pop, start=1948-01-01, frequency = 1)
is.ts(pop)
pop <- ts(pop, start=1948, frequency = 12)
## Wczytanie danych
pop <- read.csv('pop.csv')
pop <- ts(pop, start=1948, frequency = 12)
## Wczytanie danych
pop <- read.csv('pop.csv')
pop$data <- as.Date(pop$data)
colnames(pop) <- c('data','liczba')
pop$data <- as.Date(pop$data)
pop <- ts(pop, start=1948, frequency = 12)
## Wczytanie danych
pop <- read.csv('pop.csv')
colnames(pop) <- c('data','liczba')
pop <- ts(pop, start=1948, frequency = 12)
## Wczytanie danych
pop <- read.csv('pop.csv')
## Wczytanie danych
pop <- read.csv('pop.csv')
veg <- read.csv('veg.csv')
colnames(pop) <- c('data','liczba')
colnames(veg) <- c('data', 'cena')
pop$data <- as.Date(pop$data)
veg$data <- as.Date(veg$data)
pop$liczba <- as.numeric(pop$liczba)
veg$data <- as.Date(veg$data)
veg$cena <- as.numeric(veg$cena)
pop <- ts(pop, start=1948, frequency = 12)
## Wczytanie danych
pop <- read.csv('pop.csv')
veg <- read.csv('veg.csv')
colnames(pop) <- c('data','liczba')
colnames(veg) <- c('data', 'cena')
pop$data <- as.Date(pop$data)
pop$liczba <- as.numeric(pop$liczba)
veg$data <- as.Date(veg$data)
veg$cena <- as.numeric(veg$cena)
pop <- ts(pop, start=1948, frequency = 12)
## Wczytanie danych
pop <- read.csv('pop.csv')
pop <- read.csv('pop.csv')
veg <- read.csv('veg.csv')
colnames(pop) <- c('data','liczba')
colnames(veg) <- c('data', 'cena')
pop$data <- as.Date(pop$data)
pop$liczba <- as.numeric(pop$liczba)
veg$data <- as.Date(veg$data)
veg$cena <- as.numeric(veg$cena)
pop <- ts(pop$liczba, start=1948, frequency = 12)
pop
is.ts(pop)
plot(pop)
veg <- ts(veg$cena, start=1996, frequency = 12)
veg
plot(pop)
plot(veg)
monthplot(pop)
monthplot(veg)
boxplot(pop)
boxplot(pop ~ cycle(pop))
boxplot(veg ~ cycle(veg))
library(forecast)
seasonplot(pop,
col = rainbow(12),
year.labels = TRUE,
pch = 19)
seasonplot(pop,
col = rainbow(12),
year.labels = TRUE,
pch = 2)
seasonplot(pop,
col = rainbow(12),
year.labels = TRUE,
pch = 30)
seasonplot(pop,
col = rainbow(12),
year.labels = TRUE,
pch = 19)
seasonplot(pop,
col = rainbow(20),
year.labels = TRUE,
pch = 19)
seasonplot(pop,
col = rainbow(75),
year.labels = TRUE,
pch = 19)
seasonplot(veg,
col = rainbow(75),
year.labels = TRUE,
pch = 19)
seasonplot(pop,
col = rainbow(75),
year.labels = TRUE,
pch = 19)
seasonplot(veg,
col = rainbow(27),
year.labels = TRUE,
pch = 19)
lag.plot(pop, lags=12, do.lines=TRUE)
lag.plot(pop, lags=12, do.lines=TRUE)
lag.plot(pop, lags=12, do.lines=FALSE)
lag.plot(veg, lags=12, do.lines=FALSE)
acf(pop)
pafc(pop)
pacf(pop)
acf(veg)
pacf(veg)
decompore(pop)
decompose(pop)
dpop <- decompose(pop)
plot(dpop)
dveg <- decompose(veg)
plot(dveg)
dpop <- decompose(pop)
dveg <- decompose(veg, type = "additive")
dpop <- decompose(pop)
dpop <- decompose(pop, type = "additive")
dpop <- decompose(pop)
plot(dpop)
dpop <- decompose(pop, type = "additive")
plot(dpop)
#Dekompozycja multiplikatywna szeregu z trendem
dpop <- decompose(pop, type = "multiplicative")
plot(dpop)
#Dekompozycja multiplikatywna szeregu z sezonowością
dveg <- decompose(veg, type = "additive")
plot(dveg)
#Dekompozycja multiplikatywna szeregu z sezonowością
dveg <- decompose(veg, type = "multiplicative")
plot(dveg)
ts1ma1 <- filter(pop, sides=2, filter=rep(1/3,3))
ts1ma2 <- filter(pop, sides=2, filter=rep(1/7,7))
ts1ma3 <- filter(pop, sides=2, filter=rep(1/11,11))
plot(pop, col="black", lty=2)
lines(ts1,ma1, col="red", lty=2)
setwd('C:/Users/marty/Desktop/GITHUB/ts')
#Wprowadzenie
#Analizowane szeregi czasowe dotyczą wielkości populacji ludzi w wieku powyżej 55 roku życia (włącznie) oraz cen warzyw w Polsce.
#Analiza pierwszego zagadnienia ma na celu obserwację zmian zachodzących w społeczeństwie na całym świecie. Przewidywanie takich procesów jak starzenie się (lub odmładzanie) społeczeństwa wpływa np. na decyzje polityczne w sprawach polityki prorodzinnej czy prodemograficznej.
#Analiza cen warzyw w Polsce pozwoli zobrazować, jak na przestrzeni roku zmieniają się ceny warzyw. W zależności od miesiąca, wahania cen są mocno zauważalne; w trakcie zbiorów są najtańsze, a pożniej drożeją, co można powiązać np. z kosztami magazynowania i przechowywania w odpowiednich warunkach.
#Indeks harmonizowany cen towarów i usług konsumpcyjnych (Harmonized Index of Consumer Prices, HICP) jest miarą inflacji lub zmiany ogólnego poziomu cen. Wskaźnik ten jest stosowany w Unii Europejskiej do porównywania cen konsumpcyjnych między krajami członkowskimi.
#indeks 2015=100 oznacza, że wszystkie wartości indeksu są wyrażane jako odchylenia od poziomu cen z 2015 roku. Na przykład, jeśli indeks wynosi 105, oznacza to, że ceny wzrosły o 5% w porównaniu do roku referencyjnego.
#Oba zbiory danych pochodzą ze strony https://fred.stlouisfed.org/. (fred.stlouisfed.org - baza danych Rezerwy Federalnej)
#Ten dotyczący populacji obejmuje okres od stycznia 1948 do maja 2023, a drugi, dotyczący cen warzyw, od stycznia 1996 do czerwca 2023.
## Wczytanie danych
pop <- read.csv('pop.csv')
veg <- read.csv('veg.csv')
colnames(pop) <- c('data','liczba')
colnames(veg) <- c('data', 'cena')
pop$data <- as.Date(pop$data)
pop$liczba <- as.numeric(pop$liczba)
veg$data <- as.Date(veg$data)
veg$cena <- as.numeric(veg$cena)
pop <- ts(pop$liczba, start=1948, frequency = 12)
pop
veg <- ts(veg$cena, start=1996, frequency = 12)
veg
is.ts(pop)
is.ts(veg)
## Omówienie głównych cech analizowanych szeregów na podstawie poznanych typów wykresów
## Wykresy punktowe
plot(pop)
plot(veg)
## Wykresy sezonowe
monthplot(pop)
monthplot(veg)
#Powyższa funkcja pochodzi z pakietu stats i przedstawia podzbiory danych dla kazdego z okresów - dla miesięcznytch szeregów, dla każdego miesiąca rysowane są odrębne szeregi czasowe zawierające wartości zaobserwowane w kolejnych latach. Ponadto wyznacznana jest średnia wartość zaznaczona poziomą linią.
library(forecast)
seasonplot(pop,
col = rainbow(75),
year.labels = TRUE,
pch = 19)
seasonplot(veg,
col = rainbow(27),
year.labels = TRUE,
pch = 19)
#Funkcja seasonplot z pakietu forecast pozwala na zaprezentowanie danych w rozbiciu na kolejne okresy jednostkowe. Forma taka pomaga analizować i zauważać zarówno sezonowość okresów jak i odstępstwom od wzorca sezonowości w poszczególnych okresach (np. jednostkowe, nietypowe zachowanie w konkretnym roku).
## Wykresy pudełkowe
boxplot(pop ~ cycle(pop))
boxplot(veg ~ cycle(veg))
#Wykres typu boxplot dostarcza nam syntetycznych informacji na temat zmienności szeregów dla poszczególnych okresów. Na wykresie mamy mediany, kwartyle(brzegi pudełek), wartości minimalne i maksymalne(wąsy) oraz wartości odstające (kropki)
## Wykresy rozrzutu dla wartości opóźnionych
lag.plot(pop, lags=12, do.lines=FALSE)
lag.plot(veg, lags=12, do.lines=FALSE)
#Wykres rozrzutu jest podstawowym narzędziem graficznym wykorzystywanym do badania zależności dwóch zmiennych w klasycznej analizie danych. Na wykresach rozrzutu dla wartości opóźnionych przedstawiamy zależność wartości szeregu od wartości przesuniętych o opóźnienie lag - rysujemy pary (X(t), X(t-lag)) dla kolejnych chwil t. Jeżeli punkty na wykresie przedstawiają jednorodną chmurę punktów, bez jakiejkolwiek struktury, świadczy to o braku istotnej zależności czasowej pomiędzy wartościami szeregu przesuniętymi o konkretne opóźnienie.
## Wykresy autokorelacji ACF
acf(pop)
acf(veg)
## Wykresy cząstkowej korelacji PACF
pacf(pop)
pacf(veg)
## Dekompozycja
#Dekompozycja addytywna szeregu z trendem
dpop <- decompose(pop, type = "additive")
plot(dpop)
#Dekompozycja addytywna szeregu z sezonowością
dveg <- decompose(veg, type = "additive")
plot(dveg)
#Dekompozycja multiplikatywna szeregu z trendem
dpop <- decompose(pop, type = "multiplicative")
plot(dpop)
#Dekompozycja multiplikatywna szeregu z sezonowością
dveg <- decompose(veg, type = "multiplicative")
plot(dveg)
#Dekompozycja za pomocą ruchomej średniej szeregu z trendem
ts1ma1 <- filter(pop, sides=2, filter=rep(1/3,3))
ts1ma2 <- filter(pop, sides=2, filter=rep(1/7,7))
ts1ma3 <- filter(pop, sides=2, filter=rep(1/11,11))
plot(pop, col="black", lty=2)
lines(ts1ma1, col="red", lty=2)
lines(ts1ma2, col="blue", lty=2)
lines(ts1ma3, col="green", lty=2)
str(pop)
pop
## Wykresy punktowe
plot(pop)
ts1ma11 <- filter(veg, sides=2, filter=rep(1/3,3))
ts1ma22 <- filter(veg, sides=2, filter=rep(1/7,7))
ts1ma33 <- filter(veg, sides=2, filter=rep(1/11,11))
plot(veg, col="black", lty=2)
lines(ts1ma11, col="red", lty=2)
lines(ts1ma22, col="blue", lty=2)
lines(ts1ma33, col="green", lty=2)
ts1ma44 <- filter(veg, sides=2, filter=rep(1/20,20))
lines(ts1ma44, col="purple", lty=2)
ts1ma11 <- filter(veg, sides=2, filter=rep(1/3,3))
ts1ma22 <- filter(veg, sides=2, filter=rep(1/7,7))
ts1ma33 <- filter(veg, sides=2, filter=rep(1/11,11))
ts1ma44 <- filter(veg, sides=2, filter=rep(1/20,20))
plot(veg, col="black", lty=2)
#lines(ts1ma11, col="red", lty=2)
#lines(ts1ma22, col="blue", lty=2)
#lines(ts1ma33, col="green", lty=2)
lines(ts1ma44, col="purple", lty=2)
#Dekompozycja wielomianowa
ts1.tslm.poly <- tslm(pop ~ season+poly(trend, raw=TRUE,degree=2), lambda = 0)
#Dekompozycja wielomianowa
pop_poly <- tslm(pop ~ season+poly(trend, raw=TRUE,degree=2), lambda = 0)
plot(pop_poly)
#Dekompozycja wielomianowa
pop_poly <- tslm(pop ~ season + poly(trend, raw = TRUE, degree = 2), lambda = 0)
plot(pop_poly)
summary(pop.poly)
summary(pop_poly)
### D.1.1 ####
library(forecast)
wn <- rnorm(8*12, 0, 2)
WnTs <- ts(wn, frequency=12)
plot(WnTs)
Tr <- seq(0, by=0.1, length.out = 8*12 )
TrTs <- ts(Tr, frequency = 12)
plot(TrTs)
Szereg <- ts(WnTs + TrTs, frequency = 12)
plot(Szereg)
Wektor <- c(0, 2, 5, 3, 5, 2, 0, -2, -4, -5, -4, -2)
Odp <- ts(WnTs+TrTs+Wektor, frequency=12)
plot(Odp)
tsdisplay(Szereg)
tsdisplay(Odp)
## D2 ####
#Ruchome średnie
ma5 <- filter(AirPassengers, sides = 2, filter = rep(1/12,12))
plot(AirPassengers)
lines(ma5, col = "purple")
library(quantmod)
bitcoin <- getSymbols("BTC-USD",
src = "yahoo",
from = as.Date("2022-02-01"),
auto.assign = FALSE)
cena_zamk <- ts(bitcoin$`BTC-USD.Close`, frequency = 365, start=c(2022, 32))
plot(cena_zamk)
srednie7 <- filter(cena_zamk, sides=1, filter=rep(1/7,7))
srednie25 <- filter(cena_zamk, sides=1, filter=rep(1/25,25))
srednie99 <- filter(cena_zamk, sides=1, filter=rep(1/99,99))
plot(cena_zamk)
lines(srednie7,col="purple")
lines(srednie25,col="blue")
lines(srednie99,col="red")
plot(srednie7)
library(quantmod)
bitcoin <- getSymbols("BTC-USD",
src = "yahoo",
from = as.Date("2022-02-01"),
auto.assign = FALSE)
cena_zamk <- ts(bitcoin$`BTC-USD.Close`, frequency = 365, start=c(2022, 32))
plot(cena_zamk)
srednie7 <- filter(cena_zamk, sides=1, filter=rep(1/7,7))
srednie25 <- filter(cena_zamk, sides=1, filter=rep(1/25,25))
srednie99 <- filter(cena_zamk, sides=1, filter=rep(1/99,99))
plot(cena_zamk)
lines(srednie7,col="purple")
lines(srednie25,col="blue")
lines(srednie99,col="red")
pop_poly1 <- tslm(pop~trend)
pop_poly2 <- tslm(pop ~ trend + season)
plot(pop)
lines(fitted(pop_poly1), col = "blue", lty = 2)
lines(fitted(pop_poly2), col = "red", lty = 2)
lines(fitted(pop_poly1), col = "blue", lty = 4)
lines(fitted(pop_poly2), col = "red", lty = 2)
plot(pop)
lines(fitted(pop_poly1), col = "blue", lty = 4)
lines(fitted(pop_poly2), col = "red", lty = 2)
lines(fitted(pop_poly1), col = "blue", lty = 1)
lines(fitted(pop_poly2), col = "red", lty = 2)
lines(fitted(pop_poly1), col = "blue", lty = 2)
lines(fitted(pop_poly2), col = "red", lty = 1)
lines(fitted(pop_poly1), col = "blue", lty = 1)
lines(fitted(pop_poly2), col = "red", lty = 2)
veg_poly1 <- tslm(veg~trend)
veg_poly2 <- tslm(veg ~ trend + season)
plot(veg)
lines(fitted(veg_poly1), col = "blue", lty = 1)
lines(fitted(veg_poly2), col = "red", lty = 2)
ts1ma11 <- filter(veg, sides=2, filter=rep(1/3,3))
ts1ma22 <- filter(veg, sides=2, filter=rep(1/7,7))
ts1ma33 <- filter(veg, sides=2, filter=rep(1/11,11))
ts1ma44 <- filter(veg, sides=2, filter=rep(1/20,20))
plot(veg, col="black", lty=2)
lines(ts1ma11, col="red", lty=2)
lines(ts1ma22, col="blue", lty=2)
lines(ts1ma33, col="green", lty=2)
lines(ts1ma44, col="purple", lty=2)
ts1ma11 <- filter(veg, sides=2, filter=rep(1/11,11))
ts1ma22 <- filter(veg, sides=2, filter=rep(1/20,20))
ts1ma33 <- filter(veg, sides=2, filter=rep(1/25,25))
plot(veg, col="black", lty=2)
lines(ts1ma11, col="red", lty=2)
lines(ts1ma22, col="blue", lty=2)
lines(ts1ma33, col="green", lty=2)
## Eliminacja trendu i sezonowości
#Na szeregach powstałych po dekompozycji addytywnej
dpop
## Eliminacja trendu i sezonowości
#Na szeregach powstałych po dekompozycji addytywnej
dpop_trend <- dpop$trend
dpop_sesonowosc <- dpop$seasonal
dpop.indeksy <- dpop$figure
dpop.reszty <- dpop$random
## Eliminacja trendu i sezonowości
#Na szeregach powstałych po dekompozycji addytywnej
dpop.trend <- dpop$trend
dpop.sesonowosc <- dpop$seasonal
barplot(dpop.indeksy, names.arg = month.abb, main="Indeksy sezonowe")
tsdisplay(dpop.reszty, main="reszty losowe")
tsdisplay(pop)
barplot(dpop.indeksy, names.arg = month.abb, main="Indeksy sezonowe")
#Dekompozycja addytywna szeregu z trendem
dpop <- decompose(pop, type = "additive")
plot(dpop)
#Dekompozycja addytywna szeregu z sezonowością
dveg <- decompose(veg, type = "additive")
plot(dveg)
dpop.trend <- dpop$trend
dpop.sesonowosc <- dpop$seasonal
dpop.indeksy <- dpop$figure
dpop.reszty <- dpop$random
barplot(dpop.indeksy, names.arg = month.abb, main="Indeksy sezonowe")
tsdisplay(dpop.reszty, main="reszty losowe")
dveg.trend <- dveg$trend
dveg.sezonowosc <- dveg$seasonal
dveg.indeksy <- dveg$figure
dveg.reszty <- dveg$random
dveg.trend <- dveg$trend
dveg.sezonowosc <- dveg$seasonal
dveg.indeksy <- dveg$figure
dveg.reszty <- dveg$random
barplot(dveg.indeksy, names.arg = month.abb, main="Indeksy sezonowe")
tsdisplay(dveg.reszty, main="reszty losowe")
veg_poly1 <- tslm(veg~trend)
veg_poly2 <- tslm(veg ~ trend + season)
plot(veg)
lines(fitted(veg_poly1), col = "blue", lty = 1)
lines(fitted(veg_poly2), col = "red", lty = 2)
plot(pop)
lines(fitted(pop_poly2), col="red", lty=2)
tsdisplay(residuals(pop_poly2), main="reszty")
tsdisplay(residuals(pop_poly2), main="reszty")
#Na szeregach pierwotnych
popdiff <- diff(pop)
tsdisplay(popdiff)
tsdisplay(dpop.reszty, main="reszty losowe")
tsdisplay(popdiff)
popdiff1 <- diff(popdiff)
tsdisplay(popdiff1)
popdiff1 <- diff(popdiff, lag=12)
tsdisplay(popdiff1)
